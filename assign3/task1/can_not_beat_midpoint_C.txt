The reason why midpoint_A doesn't work is because I used 2,000,000,000 and 3,000,000,000 and this failed midpoint_A test. Midpoint_A overflows into the negative version of the output when the int gets too high.

The reason why midpoint_B doesn't work is I used -300 and -300 and this failed midpoint_B test. Midpoint_B does not include negative integers, and overflows when negative inputs are involved. Only unsigned 16-bit integers will output a reliable answer.

The reason why midpoint_C always works is because this equation represents the binary version of the decimal, and covers each int through this system. When passing through the integers that failed midpoint_A because it overflows, 2,000,000,000 and 3,000,000,000, midpoint_C works because their x & y and x ^ y operators are able to translate these bigger decimals, whereas simple + and - operators can't on their own and cause an overflow. Similarly, midpoint_B didn't work with the integers -300 and -300, or even -1 and -1, because unsigned integers do not and can not compute negative integers. That is what makes them unsigned. Midpoint_C uses signed integers in their function. Finally, midpoint_original fails with the integers 2147483647 and 1 because they are basic overflow. This number pushes past the bit limit, since it is only reading the decimal. Midpoint_C translates the decimal to binary, and then outputs the correct midpoint.   